#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler/setup'
require_relative '../lib/repository_merger'
require_relative '../lib/repository_merger/github_issue_reference'
require 'pry'

def main
  Signal.trap('INT') do
    puts 'Aborting...'
    exit(1)
  end

  Dir.chdir(dest_dir)

  total_import_phase_count = tag_names_unreachable_from_target_branches.size + target_branch_names.size
  current_import_phase_number = 1

  tag_names_unreachable_from_target_branches.each do |tag_name|
    tags = configuration.original_repos.map { |repo| repo.tag(tag_name) }.compact

    repo_merger.merge_commit_history_of(
      tags,
      commit_message_transformer: method(:convert_commit_message),
      progress_title: "[#{current_import_phase_number}/#{total_import_phase_count}: #{tag_name}]"
    )

    # We need to import the tags here before importing target branches
    # so that the tags will reference right commits.
    repo_merger.import_tags(tags, tag_name_transformer: method(:convert_tag_name))

    current_import_phase_number += 1
  end

  target_branch_names.each do |branch_name|
    repo_merger.merge_commit_history_of_branches_named(
      branch_name,
      commit_message_transformer: method(:convert_commit_message),
      progress_title: "[#{current_import_phase_number}/#{total_import_phase_count}: #{branch_name}]"
    )

    current_import_phase_number += 1
  end

  repo_merger.import_all_tags(tag_name_transformer: method(:convert_tag_name))

  Dir.chdir(configuration.monorepo_path) do
    # Clear index and working tree since they're cluttered after the merge
    `git reset --hard`

    # Merged repos without GC tend to have large volume
    puts 'Running `git gc`...'
    system('git gc')
  end
end

def repo_merger
  @repo_merger ||= RepositoryMerger.new(configuration)
end

def configuration
  @configuration ||= RepositoryMerger::Configuration.new(
    original_repo_paths: fetch_original_repos_if_needed,
    monorepo_path: create_monorepo_if_needed,
    verbose_logging: ARGV.include?('-v')
  )
end

def target_branch_names
  @target_branch_names ||= begin
    all_branch_names = configuration.original_repos.flat_map { |repo| repo.branches.map(&:name) }.uniq.sort
    ['origin/main'] + all_branch_names.grep(/\Aorigin\/\d+-\d+-(maintenance|stable)\z/)
  end
end

def tag_names_unreachable_from_target_branches
  %w[
    v2.0.0.beta.9
    v3.5.0.beta2
  ]
end

def convert_commit_message(original_commit)
  scope = original_commit.repo.name.sub(/\Arspec-/, '')

  message = RepositoryMerger::GitHubIssueReference.convert_repo_local_references_to_absolute_ones_in(
    original_commit.message,
    username: 'rspec',
    repo_name: original_commit.repo.name
  )

  "[#{scope}] #{message}"
end

def convert_tag_name(original_tag)
  tag_name = original_tag.name
  tag_name = "v#{tag_name}" if tag_name.match?(/\A\d+\.\d+\.\d+/)

  scope = original_tag.repo.name.sub(/\Arspec-/, '')

  "#{tag_name}-#{scope}"
end

def dest_dir
  dest_dir = 'dest'
  Dir.mkdir(dest_dir) unless Dir.exist?(dest_dir)
  dest_dir
end

def fetch_original_repos_if_needed
  repo_urls = %w[
    https://github.com/yujinakayama/rspec.git
    https://github.com/yujinakayama/rspec-core.git
    https://github.com/yujinakayama/rspec-expectations.git
    https://github.com/yujinakayama/rspec-mocks.git
    https://github.com/yujinakayama/rspec-support.git
  ]

  original_repos_dir = 'original_repos'

  Dir.mkdir(original_repos_dir) unless Dir.exist?(original_repos_dir)

  Dir.chdir(original_repos_dir) do |current_directory|
    repo_urls.map do |repo_url|
      repo_name = File.basename(repo_url, '.git')

      unless Dir.exist?(repo_name)
        system("git clone #{repo_url}")
      end

      File.join(current_directory, repo_name)
    end
  end
end

def create_monorepo_if_needed
  monorepo_dir = 'monorepo'

  unless Dir.exist?(monorepo_dir)
    Dir.mkdir(monorepo_dir)
    Dir.chdir(monorepo_dir) do
      system('git init')
    end
  end

  monorepo_dir
end

main
